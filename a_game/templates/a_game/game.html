<!DOCTYPE html>
{% extends 'layouts/blank.html' %}

{% block content %}
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ping Pong</title>
    <style>
        * { 
          margin: 0;
          padding: 0;
        }
        body { 
          overflow: hidden;
          font-family: Arial, sans-serif;
          background-color: #1F3A1F;
        }
        h1 {
          color: #fff;
          font-size: 4rem;
          position: absolute;
          bottom: 30px; 
          left: 50%;
          transform: translateX(-50%);
        }
        #player1 { 
          margin-right: 100px;
        }
        #player2 {
          margin-left: 100px;
        }
        #canvas {
          position: absolute;
          top: 50px; /* Adjust to avoid overlapping with navbar */
          width: 100%;
          height: calc(100% - 50px); /* Adjust height accordingly */
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<h1 id="player1">0</h1>
<h1 id="player2">0</h1>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 50; // Adjust for navbar height

    const keypress = [];
    const KEY_UP = 87;   // W
    const KEY_DOWN = 83; // S
    const KEY_UP2 = 38;  // Arrow Up
    const KEY_DOWN2 = 40; // Arrow Down

    // WebSocket connection
    const socket = new WebSocket('ws://' + window.location.host + '/ws/pong/');

    socket.onmessage = function(event) {
        const data = JSON.parse(event.data);
        const direction = data.direction;

        // Update paddle movement based on WebSocket direction
        if (direction === 'up') {
            paddle1.pos.y -= paddle1.speed.y;
        } else if (direction === 'down') {
            paddle1.pos.y += paddle1.speed.y;
        }
        paddle1.checkBounds();  // Ensure paddle stays within bounds
    };

    window.addEventListener('keydown', (e) => { 
        keypress[e.keyCode] = true; 
        
        // Send paddle movement to the WebSocket
        if (e.keyCode === KEY_UP || e.keyCode === KEY_DOWN) {
            const direction = e.keyCode === KEY_UP ? 'up' : 'down';
            socket.send(JSON.stringify({
                'direction': direction
            }));
        }
    });
    
    window.addEventListener('keyup', (e) => { keypress[e.keyCode] = false; });

    function vec2(x, y) {
        return { x: x, y: y };
    }
    
    function Ball(pos, speed, radius) {
        this.pos = pos;
        this.speed = speed;
        this.radius = radius;

        this.update = function() {
            this.pos.x += this.speed.x;
            this.pos.y += this.speed.y;
        };

        this.draw = function() {
            ctx.fillStyle = "#FFD700";
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        };
    }

    function Paddle(pos, speed, width, height, upKey, downKey) {
        this.pos = pos;
        this.speed = speed;
        this.width = width;
        this.height = height;
        this.score = 0;

        this.update = function() {
            if (keypress[upKey]) {
                this.pos.y -= this.speed.y;
            }
            if (keypress[downKey]) {
                this.pos.y += this.speed.y;
            }
            this.checkBounds();
        };

        this.checkBounds = function() {
            if (this.pos.y < 0) this.pos.y = 0;
            if (this.pos.y + this.height > canvas.height) this.pos.y = canvas.height - this.height;
        };

        this.draw = function() {
            ctx.fillStyle = "#0000FF";
            ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
        };

        this.getCenter = function() {
            return vec2(this.pos.x + this.width / 2, this.pos.y + this.height / 2);
        };
    }

    function ballPaddleCollision(ball, paddle) {
        let dx = Math.abs(ball.pos.x - paddle.getCenter().x);
        let dy = Math.abs(ball.pos.y - paddle.getCenter().y);

        if (dx <= (ball.radius + paddle.width / 2) && dy <= (paddle.height / 2 + ball.radius)) {
            let hitPosition = (ball.pos.y - paddle.pos.y) / paddle.height;

            ball.speed.x *= -1;
            let angle = (hitPosition - 0.5) * Math.PI / 2;
            ball.speed.y = Math.sin(angle) * 5;
        }
    }


    function respawnBall(ball) {
        if (ball.speed.x > 0) {
            ball.pos.x = canvas.width - 150;
            ball.pos.y = (Math.random() * (canvas.height - 200)) + 100;
        }
        if (ball.speed.x < 0) {
            ball.pos.x = 150;
            ball.pos.y = (Math.random() * (canvas.height - 200)) + 100;
        }

        ball.speed.x *= -1;
        ball.speed.y *= -1;
    }

    function increasescore(ball, paddle2, paddle1) {
        if (ball.pos.x <= -ball.radius) {
            paddle2.score += 1;
            document.getElementById("player2").innerHTML = paddle2.score;
            respawnBall(ball);
        }

        if (ball.pos.x >= canvas.width + ball.radius) {
            paddle1.score += 1;
            document.getElementById("player1").innerHTML = paddle1.score;
            respawnBall(ball);
        }
    }

    const paddleWidth = 10;
    const paddleHeight = 160;
    
    const ball = new Ball(vec2(500, 250), vec2(9, 5), 20);
    const paddle1 = new Paddle(vec2(10, canvas.height / 2 - paddleHeight / 2), vec2(0, 8), paddleWidth, paddleHeight, KEY_UP, KEY_DOWN);
    const paddle2 = new Paddle(vec2(canvas.width - paddleWidth - 10, canvas.height / 2 - paddleHeight / 2), vec2(0, 8), paddleWidth, paddleHeight, KEY_UP2, KEY_DOWN2);

    function gameUpdate() {
        ball.update();
        paddle1.update();
        paddle2.update();
        ballPaddleCollision(ball, paddle1);
        ballPaddleCollision(ball, paddle2);
        checkBallEdges(ball);
        increasescore(ball, paddle2, paddle1);
    }

    function checkBallEdges(ball) {
        if (ball.pos.y + ball.radius >= canvas.height || ball.pos.y - ball.radius <= 0) {
            ball.speed.y *= -1;
        }
    }

    function gameDraw() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ball.draw();
        paddle1.draw();
        paddle2.draw();
    }

    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        gameUpdate();
        gameDraw();
        requestAnimationFrame(gameLoop);
    }

    gameLoop();
</script>
</body>
{% endblock %}
</html>

